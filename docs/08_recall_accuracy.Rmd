---
title: "08 Recall and Accuracy"
author: "Rex W. Douglass and Kristen Harkness"
date: "12/9/2017"
output: 
  html_notebook:
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: inline
---

Demonstrates that georeferencing options vary terms of recall (how many event locations they recover) and accuracy (how far away their imputed locations tend to be from the true location)

```{r , results='hide', message=FALSE, warning=FALSE }
rm(list=ls()); gc()
# !diagnostics off
library(MeasuringLandscapeCivilWar)
devtools::load_all()
dir_figures <- glue(getwd(), "/../paper/figures/")

gc()

knitr::opts_knit$set(progress = TRUE, verbose = TRUE)
knitr::opts_chunk$set(fig.width=12, fig.height=8,  warning=FALSE, message=FALSE, cache=TRUE)
options(width = 160)

```

```{r}

#Load Events
events_sf <- readRDS(system.file("extdata", "events_sf.Rdata", package = "MeasuringLandscapeCivilWar")) 

events_sf_text_coord_unique <- ddply(events_sf[,c('location_text','name_clean','name_cleaner','document_district_clean','map_coordinate_clean_latitude','map_coordinate_clean_longitude')],
                                     .(location_text), transform,
      map_coordinate_has =sum(!is.na(map_coordinate_clean_latitude))
      )


```

This section calculates the recall rate and geographic accuracy of gazeteer suggestions. Recall is the number of events that receive at least one suggestion under a given set of rules. Accuracy is the distance between an observed location with a military coordinate and an imputed location for the same event. 

Accuracy is measured differently for hand rule/ensemble and every other specific decision. Hand rule/ensemble accuracy is the distance observed for the best match selected by that process.

Accuracy for the remainder of decisions is the BEST CASE accuracy for any suggestion matching that rule. For example, if the decision is "point" geometry type, then accuracy would be the smallest observed distance of every single suggestion with a point type.


```{r}

#Reload from scratch each time in case we subset sometehing weirdly
georef_all_dt <- readRDS(system.file("extdata", "georef_all_dt.Rds", package = "MeasuringLandscapeCivilWar")) 

table(events_sf$name_cleaner %in% georef_all_dt$name_cleaner) #All events are in here
table(events_sf$name_cleaner %in% georef_all_dt$name_cleaner[!is.na(georef_all_dt$georef_b)]) #7,742 events with at least one gazeteer suggestion

#Exclude all distance = 0 obs, those are self matches
georef_all_dt <- subset(georef_all_dt, 
                        !is.na(name_cleaner) & # must have a name
                        (is.na(distance_km) | distance_km!=0)  ) #Can be either missing or not zero. Only thing we drop is zero because that's a self match

#Hand Rule
setkey(georef_all_dt, event_hash, handrule) #Sort by event and then hand rule
georef_all_dt_handrule <- georef_all_dt[,.SD[1], by=list(event_hash) ] #Take the smallest hand rule score, lower is better
georef_all_dt_handrule_summary <- georef_all_dt_handrule[,list(
                                               rule="Hand Rule",
                                              distance_rmse=sqrt(mean(distance_km^2, na.rm=T)) ,
                                              source_dataset_count=.N
                                              )
                                        ]
#Ensemble Rule
setkey(georef_all_dt, rule_ensemble)
georef_all_dt_ensemble <- georef_all_dt[,.SD[1], by=list(event_hash) ] #Take the smallest estimated distance, lower is better
georef_all_dt_ensemble_summary <- georef_all_dt_ensemble[,list(
                                               rule="Ensemble Rule",
                                              distance_rmse=sqrt(mean(distance_km^2, na.rm=T)) ,
                                              source_dataset_count=.N
                                              )
                                        ]
print("Distance for Hand Rule")
summary(georef_all_dt_handrule$distance_km)

print("Distance for Ensemble")
summary(georef_all_dt_ensemble$distance_km)

rbind(georef_all_dt_handrule %>% mutate(label="hand"),
      georef_all_dt_ensemble %>% mutate(label="ensemble")) %>% 
      ggplot(aes(x=distance_km, fill=label)) + geom_histogram()


#Need to compare on just the intersection of the points they provide answers to?



```

Now calculate the minimum observed distance for any suggestion matching a specific decision.

```{r}

#Minimum distance by event-source
georef_all_dt_bysource <- georef_all_dt[,
                                        list(distance_min=min(distance_km, na.rm=T) ),
                                        by=list(event_hash, source_dataset)] ; dim(georef_all_dt_bysource)
georef_all_dt_bysource[!is.finite(distance_min), distance_min:=NA]

#Minimum distance and recall by source
georef_all_dt_bysource_summary <- georef_all_dt_bysource[,
                                                    list(
                                                      distance_rmse=sqrt(mean(distance_min^2, na.rm=T)) ,
                                                      source_dataset_count=.N),
                                                      by=list(source_dataset)
                                                ]

georef_all_dt_byfuzzy <- georef_all_dt[
                                      ,list(distance_min=min(distance_km, na.rm=T) ),
                                      by=list(event_hash, fuzzy)] ;
georef_all_dt_byfuzzy[!is.finite(distance_min), distance_min:=NA]


georef_all_dt_byfuzzy_summary <- georef_all_dt_byfuzzy[,
                                                       list(distance_rmse=sqrt(mean(distance_min^2, na.rm=T)) ,
                                                      source_dataset_count=.N),
                                                      by=list(fuzzy) ]

georef_all_dt_byselfreference <- georef_all_dt[,list(distance_min=min(distance_km, na.rm=T) ),
                                               by=list(event_hash, SelfReference)] ; dim(georef_all_dt_bysource)

georef_all_dt_byselfreference[!is.finite(distance_min), distance_min:=NA]
georef_all_dt_byselfreference_summary <- georef_all_dt_byselfreference[,list(
                                                      distance_rmse=sqrt(mean(distance_min^2, na.rm=T)) ,
                                                      source_dataset_count=.N),
                                                      by=list(SelfReference)
                                                ]


georef_all_dt_bygeometry_type <- georef_all_dt[,list(distance_min=min(distance_km, na.rm=T) ),by=list(event_hash, geometry_type
                                                                                            )] ; dim(georef_all_dt_bysource)
georef_all_dt_bygeometry_type[!is.finite(distance_min), distance_min:=NA]
georef_all_dt_bygeometry_type <- georef_all_dt_bygeometry_type[,list(
                                                      distance_rmse=sqrt(mean(distance_min^2, na.rm=T)) ,
                                                      source_dataset_count=.N),
                                                      by=list(geometry_type)
                                                ]

georef_all_dt_milcoords_summary <- data.frame(rule="Mil. Coord",
                                              distance_rmse=0,
                                              source_dataset_count=sum(!is.na(events_sf$map_coordinate_clean_latitude))
)

```

Combine and plot the results for every specific decision and the ensembles.

In terms of accuracy, we find wide variation between decisions. In brief:
Ensemble Rule > Hand Rule
Exact > Fuzzy
Point > Multipolygon > Polygon > Linestring
Match to Other Events > No Match to Other Events
events > nga > livestock_points" > historical > geonames > bing> kenya_cadastral_district > livestock_boundaries > gadm > kenya_district1962 > wikidata > google > kenya_cadastral > openstreetmap > tgn 

The hand rules and supervised ensemble represent a compromsie between high recovery rate and best case accuracy of each individual decision.


```{r}

recall_accuracy <- rbindlist(list(
  georef_all_dt_milcoords_summary %>% mutate(label="Mil. Coord") %>% mutate(Type="Rule"),
  georef_all_dt_handrule_summary %>% mutate(label="Hand Rule") %>% mutate(Type="Rule"),
  georef_all_dt_ensemble_summary %>% mutate(label="Ensemble Rule") %>% mutate(Type="Rule"),
  georef_all_dt_bysource_summary %>% mutate(label=source_dataset) %>% mutate(Type="Source Gazetteer"),
  georef_all_dt_byfuzzy_summary %>% mutate(label=ifelse(fuzzy, "Fuzzy","Exact")) %>% mutate(Type="Match Type"),
  georef_all_dt_byselfreference_summary %>% mutate(label=ifelse(SelfReference, "Match To Other Events","No Match To Other Events")) %>% mutate(Type="Allow Match To Other Events"),
  georef_all_dt_bygeometry_type %>% mutate(label=geometry_type) %>% mutate(Type="Geometry Type")
))

p_load(ggrepel, tools)
p1 <- ggplot(recall_accuracy %>% 
               filter(rule!="tgn") %>% #exclude TGN for being an outlier
               mutate(label=toTitleCase(gsub("_"," ",label))
                      ),
       aes(x=distance_rmse,
           y=source_dataset_count / 10469 ,
           label=label,
           color=Type)) + 
       geom_text_repel(size=3) + 
       #coord_trans(x = "log10", y = "log10") + 
       theme_bw() + 
       xlab("Root Mean Squared Distance from Observed Coordinate (km)") + 
       ylab("Recovery Rate") #+ 
       #ggtitle("Recall and Accuracy by Georeferencing Strategy")

p1

ggsave(
  filename = glue(dir_figures, "RecallBias.pdf"),
  plot = p1, width = 12, height = 6
)

#This works but I need to add some additional categories
#original coordinates
#district



```


